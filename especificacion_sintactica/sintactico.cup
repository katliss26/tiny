package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=false;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
:}

/* Simbolos Terminales */

terminal BOOL;
terminal VOID;
terminal INT;
terminal BEGIN;
terminal AND;
terminal FUNCTION;
terminal OR;
terminal RETURN;
terminal COMA;
terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal LCORCH;
terminal RCORCH;
terminal FOR;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
/*Declaraciones nuevas*/
terminal GT;
terminal GE;
terminal LE;
terminal NEQ;
/*-----------*/
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase start_block;
non terminal NodoBase start_principal;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase func_stmt;
non terminal NodoBase arg_stmt;
non terminal NodoBase cont_void;
non terminal NodoBase cont_type;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase for_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase logic_stmt;
non terminal NodoBase assign_Func;
non terminal NodoBase arg_assign_stmt;
non terminal NodoBase arg_element;
non terminal NodoBase arg_sum_resta;
non terminal NodoBase arg_div_mult;
non terminal NodoBase arg_assign_type;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal NodoBase for_assign;
non terminal NodoBase dec;
non terminal NodoBase type_stmt;
non terminal NodoBase numNeg;
/* Precedencia de operadores */
precedence left AND;
precedence left OR;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left OVER;

/* REGLAS GRAMATICALES */

program     ::=  start_block:s	{:System.out.println("\t regla 1"); 
					ast = s;
					:}
			;
start_block	::=  func_stmt:fc start_block 
				{:
					System.out.println("\t Una o mas Funciones");
					RESULT = fc;
				:}
				| start_principal:st
				{:System.out.println("\t ir a el bloque principal");
					RESULT = st;
				:}			
			;
start_principal ::= BEGIN stmt_seq:s END	
				{: System.out.println("\t Bloque principal");
					RESULT=s;
				:}
			;	
func_stmt 	::= VOID FUNCTION ID LPAREN RPAREN 
				cont_void:cont_v
				{: if(modoDepuracion) System.out.println("\t funcion VOID sin parametros"); 
					RESULT=cont_v;
					:}
				|BOOL FUNCTION ID LPAREN RPAREN
				cont_type:cont_t
				{: if(modoDepuracion) System.out.println("\t funcion BOOL sin parametros");
					RESULT=cont_t; 
					:}
				|INT FUNCTION ID LPAREN RPAREN 
				cont_type:cont_t
				{: if(modoDepuracion) System.out.println("\t funcion INT sin parametros"); 
					RESULT=cont_t;
					:}
				|VOID FUNCTION ID LPAREN arg_stmt RPAREN /*CrearNodo*/
				cont_void:cont_v
				{: if(modoDepuracion) System.out.println("\t funcion VOID con parametros"); 
					RESULT=cont_v;
					:}
				|BOOL FUNCTION ID LPAREN arg_stmt RPAREN 
				cont_type:cont_t
				{: if(modoDepuracion) System.out.println("\t funcion BOOL con parametros"); 
					RESULT=cont_t;
					:}
				|INT FUNCTION ID LPAREN arg_stmt RPAREN 
				cont_type:cont_t
				{: if(modoDepuracion) System.out.println("\t funcion INT con parametros"); 
					RESULT=cont_t;
					:}
		;
cont_void	::= BEGIN 
					stmt_seq:st_s
				END
				{: if(modoDepuracion) System.out.println("\t funcion INT con parametros"); 
					RESULT=st_s;
					:}
			;
cont_type	::= BEGIN 
					stmt_seq:st_s
					RETURN simple_exp:s_e SEMI
				END/*CrearNodo*/
				{: if(modoDepuracion) System.out.println("\t funcion INT con parametros"); 
					RESULT=st_s;
					:}
				|
				BEGIN 
					RETURN simple_exp:s_e SEMI
				END
				{: if(modoDepuracion) System.out.println("\t funcion INT con parametros"); 
					RESULT=s_e;
					:}
			;			
arg_stmt	::= BOOL ID COMA arg_stmt:ar_st 
				{: if(modoDepuracion) System.out.println("\t Argumento 1"); 
					/*RETURN=:ar_st;*/
					:}
				| INT ID COMA arg_stmt:ar_st
				{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					/*RETURN=:ar_st;*/
					:}
				| INT ID
				{: if(modoDepuracion) System.out.println("\t Argumento 3"); 
					:}
				| BOOL ID
				{: if(modoDepuracion) System.out.println("\t Argumento 4"); 
					:}
		;

stmt_seq    ::= stmt_seq:ini stmt:sent	{: if(modoDepuracion) System.out.println("\t regla 2a"); 
						NodoBase hijoActual = ini;
						if(hijoActual !=null){
							while(hijoActual.TieneHermano()){
								hijoActual = hijoActual.getHermanoDerecha();
							}
							hijoActual.setHermanoDerecha(sent);
							RESULT=ini;
						}else{
							RESULT=sent;
						}
						:}
            | stmt:sent	{: if(modoDepuracion) System.out.println("\t regla 2b"); 
				RESULT=sent;				
				:}
		;



stmt        ::= if_stmt:sif	{: if(modoDepuracion) System.out.println("\t regla 3a"); 
					RESULT=sif;
					:}
            | repeat_stmt:srep	{: if(modoDepuracion) System.out.println("\t regla 3b"); 
						RESULT=srep;
						:}
			| for_stmt:sfor	{: if(modoDepuracion) System.out.println("\t regla 3b.1"); 
						RESULT=sfor;
						:}
			| assign_Func:safun	{: if(modoDepuracion) System.out.println("\t regla 3e"); 
					RESULT=safun;
					:}
            | assign_stmt:sasi	{: if(modoDepuracion) System.out.println("\t regla 3c"); 
						RESULT=sasi;
						:}
            | read_stmt:slec	{: if(modoDepuracion) System.out.println("\t regla 3d"); 
					RESULT=slec;
					:}
            | write_stmt:sesc 	{: if(modoDepuracion) System.out.println("\t regla 3e"); 
					RESULT=sesc;
					:}
			| type_stmt:styp	{: if(modoDepuracion) System.out.println("\t regla 3f"); 
						RESULT=styp;
						:}
            | error	{: if(modoDepuracion) System.out.println("\t regla 3g"); 
				System.out.println("Ocurrio error en cup # 0004");
				RESULT=null;
				:}
            ;

if_stmt     ::= IF logic_stmt:ex THEN stmt_seq:pthen END	{: if(modoDepuracion) System.out.println("\t regla 4a"); 
		RESULT = new NodoIf(ex,pthen);
		:}
		| IF logic_stmt:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END	{: if(modoDepuracion) System.out.println("\t regla 4b"); 
		RESULT = new NodoIf(ex,pthen,pelse);		
		:}
		;

repeat_stmt ::= REPEAT stmt_seq:cuerpo UNTIL logic_stmt:prueba SEMI {: if(modoDepuracion) System.out.println("\t regla 5"); 
							RESULT = new NodoRepeat(cuerpo,prueba);
							:}
		;

for_stmt	::=	FOR LPAREN for_assign:as SEMI exp:ex SEMI for_assign:se  RPAREN
					stmt_seq:cont
				END
				{: if(modoDepuracion) System.out.println("\t regla FOR"); 
							RESULT = new NodoFor(as,ex,se,cont);
							:}
							;
for_assign	::=	ID:variable {: if(modoDepuracion) System.out.println("\t regla 6 parte del medio"); 
				/*lineanum=1000; //Pasar/Obtener la linea correcta por el Simbolo
				String nombre = variable.getName();*/
				:}
			ASSIGN exp:ex	{: if(modoDepuracion) System.out.println("\t regla 6 parte final");
					if(variable!=null)
					RESULT = new NodoAsignacion(variable.toString(),ex);
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0001");
					}
					:}
		;
assign_Func ::=  ID LPAREN RPAREN SEMI
				{: if(modoDepuracion) System.out.println("\t funcion sin asignacion y sin parametros"); 
				:}
				| ID ASSIGN ID LPAREN arg_assign_stmt RPAREN SEMI
				{: if(modoDepuracion) System.out.println("\t funcion sin asignacion y con parametros"); 
				:}
				|ID ASSIGN ID LPAREN RPAREN SEMI
				{: if(modoDepuracion) System.out.println("\t funcion con asignacion y sin parametros"); 
				:}
				| ID LPAREN arg_assign_stmt RPAREN SEMI
				{: if(modoDepuracion) System.out.println("\t funcion VOID sin parametros"); 
				:}
				;

arg_assign_stmt ::= arg_assign_stmt COMA arg_sum_resta
					{: if(modoDepuracion) System.out.println("\t funcion VOID sin parametros"); 
					:} 
					| arg_sum_resta
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
		;
arg_sum_resta	::=	arg_sum_resta PLUS arg_div_mult
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| arg_sum_resta MINUS arg_div_mult
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| arg_div_mult
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					;
					
arg_div_mult	::=	arg_div_mult OVER arg_element
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| arg_div_mult TIMES arg_element 
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| arg_element
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					;

arg_element		::=  ID LPAREN RPAREN
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| ID LPAREN arg_assign_type RPAREN 
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| factor
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					;

arg_assign_type	::=  arg_assign_type COMA exp 
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					| exp 
					{: if(modoDepuracion) System.out.println("\t Argumento 2"); 
					:}
					;
assign_stmt ::= ID:variable 	/*{: if(modoDepuracion) System.out.println("\t regla 6 parte del medio"); 
				lineanum=1000; //Pasar/Obtener la linea correcta por el Simbolo
				String nombre = variable.getName();
				:}*/
				ASSIGN exp:ex SEMI	{: if(modoDepuracion) System.out.println("\t regla 6 parte final");
					if(variable!=null)
					RESULT = new NodoAsignacion(variable.toString(),ex);
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0001");
					}
					:}
				| ID:declaracion LCORCH simple_exp:sp RCORCH ASSIGN exp:ex SEMI
		    	{:
					System.out.println("HEE DECLARE UN VECTOR");
					/*RESULT  = NodoVector(declaracion,sp);*/
				:}
		;	

read_stmt   ::= READ ID:variable SEMI	{: if(modoDepuracion) System.out.println("\t regla 7"); 
					System.out.println("Leyendo Variable");
					if(variable!=null)
					RESULT = new NodoLeer(variable.toString());
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0002");
					}
					:}
		;

write_stmt  ::= WRITE exp:ex SEMI	{: if(modoDepuracion) System.out.println("\t regla 8"); 
				       	RESULT= new NodoEscribir(ex);
					:}
		;
/* implementando OR & AND */
logic_stmt	::= 	exp:exI OR logic_stmt:exD {:
	                if(modoDepuracion) System.out.println("\t regla 13a"); 
					/*RESULT=new NodoOperacion(exI,tipoOp.or,exD);*/
					:}
				  	|exp:exI AND logic_stmt:exD {:
					 if(modoDepuracion) System.out.println("\t regla 13b");
					 /*RESULT=new NodoOperacion(exI,tipoOp.and,exD); */
					:}
					|exp:ex{:
                      RESULT=ex;
					:}
		;
type_stmt  ::= INT dec:di SEMI {: if(modoDepuracion) System.out.println("\t regla 8x"); 
				       	System.out.println("\t tipo INT");
				       	/*CrearNodo?*/
				       	/*RESULT= new NodoEscribir(dec);*/
				:}
				| BOOL dec:db SEMI {: if(modoDepuracion) System.out.println("\t regla 8x"); 
				       	System.out.println("\t tipo BOOL");
				       	/*CrearNodo?*/
				       	/*RESULT= new NodoEscribir(dc);*/
					:}		
		;

dec        ::= ID:var COMA dec:exD	{: if(modoDepuracion) System.out.println("\t regla 11a"); 
							System.out.println("\t dec"); 
							/*CrearNodo?*/
							/*RESULT = new NodoOperacion(exI,tipoOp.por,exD);*/
							:}
            | ID:var	
            {: if(modoDepuracion) System.out.println("\t regla 11c"); 
            /*CrearNodo?*/
	        /*RESULT=ex;*/
	        System.out.println("\t ID"); 
	        :}
	        | ID LCORCH simple_exp RCORCH COMA dec:exD
            {: if(modoDepuracion) System.out.println("\t regla 11c"); 
	        /*RESULT=ex;*/
	        System.out.println("\t ID"); 
	        :}
	        | ID LCORCH simple_exp RCORCH
            {: if(modoDepuracion) System.out.println("\t regla 11c"); 
	        /*RESULT=ex;*/
	        System.out.println("\t ID"); 
	        :}
		;


exp         ::= simple_exp:exI LT simple_exp:exD{:
             		if(modoDepuracion) System.out.println("\t regla 9a"); 
              		   RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
                :}
                | simple_exp:exI GT simple_exp:exD{:
                           
                  	if(modoDepuracion) System.out.println("\t regla 9a.1"); 
              		   RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
                :} 
                | simple_exp:exI LE simple_exp:exD{:
                      
                      if(modoDepuracion) System.out.println("\t regla 9a.2"); 
              		   RESULT = new NodoOperacion(exI,tipoOp.menor_eq,exD);
                      
                :} 
                | simple_exp:exI GE simple_exp:exD{:
                  
                  if(modoDepuracion) System.out.println("\t regla 9a.3"); 
              	     RESULT = new NodoOperacion(exI,tipoOp.mayor_eq,exD);
                  
                :} 
			    |simple_exp:exI EQ simple_exp:exD{:
					if(modoDepuracion) System.out.println("\t regla 9b"); 
					   RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
				 :}
				|simple_exp:exI NEQ simple_exp:exD{:
				  if(modoDepuracion) System.out.println("\t regla 9b"); 
					   RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
				  
				 :}
				| simple_exp:ex	{: 
					if(modoDepuracion) System.out.println("\t regla 9c"); 
					RESULT = ex;
					:}
		;

simple_exp  ::= simple_exp:exI PLUS term:exD	{: if(modoDepuracion) System.out.println("\t regla 10a"); 
							RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
							:}
		| simple_exp:exI MINUS term:exD	{: if(modoDepuracion) System.out.println("\t regla 10b"); 
							RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
							:}
		| term:ex	{: if(modoDepuracion) System.out.println("\t regla 10c"); 
				RESULT=ex;
				:}
		;

term        ::= term:exI TIMES factor:exD	{: if(modoDepuracion) System.out.println("\t regla 11a"); 
							RESULT = new NodoOperacion(exI,tipoOp.por,exD);
							:}
		| term:exI OVER factor:exD	{: if(modoDepuracion) System.out.println("\t regla 11b"); 
						RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
						:}
		| factor:ex	{: if(modoDepuracion) System.out.println("\t regla 11c"); 
					RESULT=ex;
					:}
		;

factor      ::= LPAREN exp:ex RPAREN	{: if(modoDepuracion) System.out.println("\t regla 12a"); 
							RESULT = ex;
							:}
		| NUM:valor	{: if(modoDepuracion) System.out.println("\t regla 12b"); 
					System.out.println("Devolvi nodo numero entero");
					if(valor!=null){
						RESULT= new NodoValor(valor);					
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0005");
					}
					:}
		| ID:variable	{: if(modoDepuracion) System.out.println("\t regla 12c"); 
					if(variable!=null){
						System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
						RESULT= new NodoIdentificador(variable.toString());		
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0005");
					}
					:}
		| ID:declaracion LCORCH simple_exp:sp RCORCH{:
		System.out.println("HEE DECLARE UN VECTOR");
		/*RESULT  = NodoVector(declaracion,sp);*/
					:}
		| numNeg {: if(modoDepuracion) System.out.println("\t regla 12a"); 
							System.out.println("numNeg");
							/*CrearNodo*/
							/*RESULT = ex;*/
							:}
		| error	{: if(modoDepuracion) System.out.println("\t regla 12d"); 
				System.out.println("Ocurrio error en cup # 0003");
				RESULT=null;
				:}
		;

numNeg     	::= MINUS factor:neg	{: if(modoDepuracion) System.out.println("\t regla 11a"); 
							System.out.println("\t negativo"); 
							RESULT = neg;
							:}
		;